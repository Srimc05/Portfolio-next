import { BlogLayout } from "@/components/BlogLayout";

import { CodeWindow } from "@/components/CodeWindow";

export const meta = {
  date: "2025-07-09",
  title: "Writing Clean Code With React",
  description:
    "Effective and efficient ways to write clean code with React while keeping in mind the performance and maintainability of the codebase.",
  image:
    "https://images.unsplash.com/photo-1542831371-29b0f74f9713?q=80&w=3540&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
  tags: ["Clean Code"],
};

export default (props) => <BlogLayout meta={meta} {...props} />;

Writing clean code with React is not just about aesthetics—it’s about building applications that are easy to understand, maintain, and scale. In the dynamic world of frontend development, where codebases can grow complex quickly, clean code serves as a foundation for long-term success.

One of the first steps toward writing clean code is using meaningful names for your components and variables. A clearly named component, like UserProfileCard, immediately tells you what it does. This makes the code more intuitive for others—and your future self—to read and modify.

Keeping components small and focused is another essential habit. Each React component should ideally follow the single responsibility principle—doing just one job. When a component grows too large, it’s a signal to break it down into smaller, reusable pieces. This not only improves readability but also encourages reusability and testing.

Destructuring props is a small yet powerful step toward clarity. Instead of constantly accessing properties via props.name or props.email, destructuring allows cleaner syntax and reduces clutter. It also helps you focus only on the data your component actually uses.

A clean React component also separates logic and styling from the JSX. Inline logic and styles can make your return statement messy and hard to follow. Moving these concerns outside keeps the JSX lean and more visually organized. This way, your code resembles a well-structured story instead of a jumbled mess.

As your application grows, repetitive logic across components becomes common. That’s where custom hooks come in. By abstracting shared logic into custom hooks, you create more modular and testable code. This keeps components focused solely on rendering and interaction.

Project structure also plays a huge role in code cleanliness. Organizing files by feature or type—such as components, hooks, pages, and utilities—prevents clutter and makes navigation simpler for everyone on the team. A well-structured project is easier to scale and onboard new developers into.

Lastly, combining your clean code habits with tools like ESLint, Prettier, and TypeScript brings consistency and safety. These tools catch bugs early, enforce style guidelines, and ensure your code behaves as expected across your app.

In conclusion, writing clean code in React means writing thoughtful, intentional code. It’s about clarity, simplicity, and long-term maintainability. When your code is easy to read and reason about, you build faster, debug better, and scale confidently. Clean code isn’t a goal—it’s a mindset. Embrace it, and your React apps will thank you.

<CodeWindow title="BoxesContainer.tsx">

```TSX
import React from "react";
import { motion } from "framer-motion";

export const BoxesContainer = () => {
  const rows = new Array(150).fill(1);
  const cols = new Array(100).fill(1);
  let colors = [
    "--sky-300",
    "--pink-300",
    "--green-300",
    "--yellow-300",
    "--red-300",
    "--purple-300",
    "--blue-300",
    "--indigo-300",
    "--violet-300",
  ];
  const getRandomColor = () => {
    return colors[Math.floor(Math.random() * colors.length)];
  };

  return (
    <div
      style={{
        transform: `translate(-40%,-60%) skewX(-48deg) skewY(14deg) scale(0.675) rotate(0deg) translateZ(0)`,
      }}
      className="absolute left-1/4 p-4 -top-1/4 flex  -translate-x-1/2 -translate-y-1/2 w-full h-full z-0 "
    >
      {rows.map((_, i) => (
        <motion.div
          key={`row` + i}
          className="w-16 h-8  border-l  border-slate-700 relative"
        >
          {cols.map((_, j) => (
            <motion.div
              whileHover={{
                backgroundColor: `var(${getRandomColor()})`,
                transition: { duration: 0 },
              }}
              animate={{
                transition: { duration: 2 },
              }}
              key={`col` + j}
              className="w-16 h-8  border-r border-t border-slate-700 relative"
            >
              {j % 2 === 0 && i % 2 === 0 ? (
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  strokeWidth="1.5"
                  stroke="currentColor"
                  className="absolute h-6 w-10 -top-[14px] -left-[22px] text-slate-700 stroke-[1px] pointer-events-none"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    d="M12 6v12m6-6H6"
                  />
                </svg>
              ) : null}
            </motion.div>
          ))}
        </motion.div>
      ))}
    </div>
  );
};

```

</CodeWindow>
